import { NextRequest, NextResponse } from 'next/server';
import { getFalAIService } from '@/lib/fal-ai';
import { uploadFile, generateFileKey, getPublicUrl } from '@/lib/storage';

export async function POST(request: NextRequest) {
  try {
    const formData = await request.formData();
    const file = formData.get('image') as File;
    const style = formData.get('style') as string;

    if (!file || !style) {
      return NextResponse.json(
        { error: 'Missing image or style parameter' },
        { status: 400 }
      );
    }

    // Validate file type
    if (!file.type.startsWith('image/')) {
      return NextResponse.json(
        { error: 'Invalid file type. Please upload an image.' },
        { status: 400 }
      );
    }

    // Validate file size (10MB limit)
    if (file.size > 10 * 1024 * 1024) {
      return NextResponse.json(
        { error: 'File too large. Please upload an image smaller than 10MB.' },
        { status: 400 }
      );
    }

    // Upload original file to R2 (if configured) or use local processing
    let originalUrl = '';
    if (process.env.CLOUDFLARE_R2_BUCKET_NAME) {
      const originalKey = generateFileKey('originals', file.name);
      const uploadResult = await uploadFile(file, originalKey);
      originalUrl = uploadResult.url;
    } else {
      // Convert to base64 for local development
      const bytes = await file.arrayBuffer();
      const buffer = Buffer.from(bytes);
      originalUrl = `data:${file.type};base64,${buffer.toString('base64')}`;
    }

    try {
      // Get FAL AI service
      const falAI = getFalAIService();

      // Stage the room using FAL AI
      console.log(`Staging room with style: ${style}`);
      const result = await falAI.stageRoom(originalUrl, style);

      if (!result.images || result.images.length === 0) {
        throw new Error('No images generated by FAL AI');
      }

      // Get the staged image URL
      const stagedImageUrl = result.images[0].url;

      // If using R2, download and re-upload the staged image
      let finalStagedUrl = stagedImageUrl;
      if (process.env.CLOUDFLARE_R2_BUCKET_NAME) {
        try {
          // Download the staged image
          const imageResponse = await fetch(stagedImageUrl);
          if (!imageResponse.ok) {
            throw new Error('Failed to download staged image');
          }

          const imageBuffer = await imageResponse.arrayBuffer();
          const stagedFile = new File([imageBuffer], `staged-${Date.now()}.png`, {
            type: 'image/png'
          });

          const stagedKey = generateFileKey('staged', `staged-${Date.now()}.png`);
          const stagedUploadResult = await uploadFile(stagedFile, stagedKey);
          finalStagedUrl = stagedUploadResult.url;
        } catch (uploadError) {
          console.error('Error uploading staged image to R2:', uploadError);
          // Fall back to original URL
          finalStagedUrl = stagedImageUrl;
        }
      }

      // Return the successful response
      return NextResponse.json({
        success: true,
        originalUrl,
        stagedUrl: finalStagedUrl,
        style: style,
        metadata: {
          seed: result.seed,
          timings: result.timings,
          hasNsfwConcepts: result.has_nsfw_concepts
        }
      });

    } catch (falError) {
      console.error('FAL AI error:', falError);
      
      // Return a more user-friendly error
      return NextResponse.json(
        { 
          error: 'Failed to stage image with AI. Please try again.',
          details: falError instanceof Error ? falError.message : 'Unknown AI error'
        },
        { status: 500 }
      );
    }

  } catch (error) {
    console.error('Staging error:', error);
    return NextResponse.json(
      { 
        error: 'Failed to stage image. Please try again.',
        details: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}